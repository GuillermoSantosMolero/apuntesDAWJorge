##########################################  A  P  U  N  T  E  S  ##########################################

PROCEDIMIENTOS:

--------->>>>>>>>>>>>>>>>>JUEGO AMIGO INVISIBLE:

create or replace PROCEDURE JUEGOAMIGOINVISIBLE AS 
TYPE T_ARRAYPTC IS TABLE OF PARTICIPANTE%ROWTYPE INDEX BY BINARY_INTEGER;
V_PARTICIPANTES T_ARRAYPTC;
CURSOR C_PARTICIPANTES IS
    SELECT CODIGO,NOMBRE,DBMS_RANDOM.VALUE ORDEN
    FROM PARTICIPANTE
    ORDER BY ORDEN FOR UPDATE;
V_CONTADOR NUMBER:=1;
BEGIN
  FOR CONTA IN C_PARTICIPANTES LOOP
    V_PARTICIPANTES(V_CONTADOR).CODIGO:=CONTA.CODIGO;
    V_PARTICIPANTES(V_CONTADOR).NOMBRE:=CONTA.NOMBRE;
    V_CONTADOR:=V_CONTADOR+1;
  END LOOP;
  FOR INDICE IN 1..V_PARTICIPANTES.LAST LOOP
    IF(INDICE!=V_PARTICIPANTES.LAST)THEN
        INSERT INTO AMIGO VALUES(V_PARTICIPANTES(INDICE).CODIGO,V_PARTICIPANTES(INDICE).NOMBRE,V_PARTICIPANTES(INDICE+1).CODIGO,V_PARTICIPANTES(INDICE+1).NOMBRE);
    ELSE
        INSERT INTO AMIGO VALUES(V_PARTICIPANTES(INDICE).CODIGO,V_PARTICIPANTES(INDICE).NOMBRE,V_PARTICIPANTES(1).CODIGO,V_PARTICIPANTES(1).NOMBRE);
    END IF;
  END LOOP;
  EXCEPTION 
  WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20000,'No hay participantes');
END JUEGOAMIGOINVISIBLE;


-------->>>>>>>>>>>>>>>>> MÉTODO PARA SABER GENTE QUE APARECE DOS VECES

create or replace PROCEDURE GETDUPLICADOS IS 
CURSOR C_PERSONAS IS
SELECT *
FROM PERSONA
FOR UPDATE WAIT 3;
V_VECESREPETIDO NUMBER:=0;
BEGIN
    FOR V_PERSONA IN C_PERSONAS LOOP
        SELECT COUNT(*) INTO V_VECESREPETIDO FROM PERSONA WHERE PERSONA.DNI=V_PERSONA.DNI;
        IF V_VECESREPETIDO!=1 THEN
            INSERT INTO PERSONA_DUPLICADA VALUES (V_PERSONA.ID,V_PERSONA.DNI,V_PERSONA.NOMBRE);
        END IF;
    END LOOP;
END GETDUPLICADOS;

--------->>>>>>>>>>>>>>>PAQUETE BANCO

PARTE DECLARATIVA:----------------


create or replace PACKAGE BANCO AS 

  /* TODO enter package declarations (types, exceptions, methods etc) here */ 
V_BANCO CONSTANT VARCHAR2(4):='0036';
FUNCTION CALCULO_DC (P_ENTIDADOFICINA IN VARCHAR2,P_NCUENTA IN VARCHAR2) RETURN VARCHAR2;
FUNCTION VALIDARNUMEROCUENTA (P_CUENTA IN VARCHAR2) RETURN BOOLEAN;
PROCEDURE ADDCUENTAPROPIA (P_SUCURSAL IN VARCHAR2, P_SALDO IN cuenta.saldo%TYPE);
PROCEDURE ADDCUENTAAJENA (P_NCUENTA VARCHAR2);
PROCEDURE INGRESO (P_NCUENTA VARCHAR2, P_CANTIDADINGRESO NUMBER, P_CONCEPTO VARCHAR2);
PROCEDURE CARGO (P_NCUENTA VARCHAR2, P_CANTIDADcargo NUMBER, P_CONCEPTO VARCHAR2);
PROCEDURE TRANSFERENCIA (P_CUENTAACREEDORA VARCHAR2, P_CUENTADEUDORA VARCHAR2, P_IMPORTE NUMBER, P_CONCEPTO VARCHAR2);
END BANCO;


PARTE BODY:------------------------

create or replace PACKAGE BODY BANCO AS

--FUNCION QUE CALCULA DIGITOS DE CONTROL
FUNCTION CALCULO_DC 
(
  P_ENTIDADOFICINA IN VARCHAR2
, P_NCUENTA IN VARCHAR2 
) RETURN VARCHAR2 AS
V_ENTIDADOFICINA VARCHAR2(8):=P_ENTIDADOFICINA;
V_NCUENTA VARCHAR2(10):=P_NCUENTA;
TYPE T_MULTIPLICADOR is varray(10)of binary_integer;
V_MULTIPLICADOR T_MULTIPLICADOR:=T_MULTIPLICADOR(6,3,7,9,10,5,8,4,2,1);
V_DIGITOSCONTROL VARCHAR2(2);
V_SUMA NUMBER:=0;
V_INDICEMULTIPLICADO NUMBER;
V_RESTO NUMBER;
V_RESULTADO NUMBER;
BEGIN
--PRIMER DIGITO
    V_INDICEMULTIPLICADO:=LENGTH(V_ENTIDADOFICINA);
    FOR CONTADOR IN 1..LENGTH(V_ENTIDADOFICINA) LOOP
        V_SUMA:=V_SUMA+(TO_NUMBER(SUBSTR(V_ENTIDADOFICINA,V_INDICEMULTIPLICADO,1))*V_MULTIPLICADOR(CONTADOR));
        V_INDICEMULTIPLICADO:=V_INDICEMULTIPLICADO-1;
    END LOOP;
    V_RESTO:= MOD(V_SUMA,11);
    V_RESULTADO:=11-V_RESTO;
    IF V_RESULTADO=10 or V_RESULTADO=11 THEN
         V_RESULTADO:=11-V_RESULTADO;
    END IF;
    V_DIGITOSCONTROL:=TO_CHAR(V_RESULTADO);
--SEGUNDO DIGITO 
    V_INDICEMULTIPLICADO:=LENGTH(V_NCUENTA);
    V_SUMA:=0;
    FOR CONTADOR IN 1..LENGTH(V_NCUENTA) LOOP
        V_SUMA:=V_SUMA+(TO_NUMBER(SUBSTR(V_NCUENTA,V_INDICEMULTIPLICADO,1))*V_MULTIPLICADOR(CONTADOR));
        V_INDICEMULTIPLICADO:=V_INDICEMULTIPLICADO-1;
    END LOOP;
    V_RESTO:= MOD(V_SUMA,11);
    V_RESULTADO:=11-V_RESTO;
    IF V_RESULTADO=10 or V_RESULTADO=11 THEN
         V_RESULTADO:=11-V_RESULTADO;
    END IF;
     V_DIGITOSCONTROL:=V_DIGITOSCONTROL||TO_CHAR(V_RESULTADO);
  RETURN V_DIGITOSCONTROL;
END CALCULO_DC;

--PROCEDIMIENTO PARA AÑADIR UNA CUENTA PROPIA
PROCEDURE ADDCUENTAPROPIA (P_SUCURSAL IN VARCHAR2, P_SALDO IN cuenta.saldo%TYPE) IS
V_ULTIMACUENTA NUMBER;
V_NCUENTA NUMBER;
V_DIGITOSCONTROL VARCHAR2(2);
V_SUCURSAL VARCHAR2(4);
E_SUCURSALINCORRECTA EXCEPTION;
BEGIN
    V_SUCURSAL:=P_SUCURSAL;
IF LENGTH(V_SUCURSAL)=4 THEN
    SELECT S_NUMEROCUENTA.NEXTVAL INTO V_ULTIMACUENTA
    FROM DUAL;
    V_NCUENTA:=(V_ULTIMACUENTA+1);
    V_DIGITOSCONTROL:=CALCULO_DC(V_BANCO||V_SUCURSAL,TO_CHAR(V_NCUENTA));
    INSERT INTO CUENTA VALUES (V_BANCO||V_SUCURSAL||V_DIGITOSCONTROL||TO_CHAR(V_NCUENTA,'FM0000000000'),'PROPIA',P_SALDO);
ELSE 
    RAISE E_SUCURSALINCORRECTA;
END IF;
EXCEPTION
WHEN E_SUCURSALINCORRECTA THEN
    RAISE_APPLICATION_ERROR(-20000, 'SUCURSAL INTRODUCIDA NO VÁLIDA');
END ADDCUENTAPROPIA;

--Funcion que devuelve true or false dependiendo de si el numero de cuenta esta bien o mal
FUNCTION VALIDARNUMEROCUENTA 
(
  P_CUENTA IN VARCHAR2 
) RETURN BOOLEAN AS 
V_CUENTA VARCHAR2(30):=P_CUENTA;
V_DC NUMBER:=0;
V_DCCORRECTO NUMBER;
V_RESULTA BOOLEAN:=TRUE;
---------------------------------------------------------------------------------------------
FUNCTION VALIDADOR_NUMERO (P_FRASE IN VARCHAR2) RETURN BOOLEAN AS 
V_FRASE VARCHAR2(200):=P_FRASE;
V_INDICE NUMBER:=1;
V_RESULTADO BOOLEAN:=TRUE;
V_ASCII NUMBER;
BEGIN
    WHILE V_INDICE <=LENGTH(V_FRASE) AND V_RESULTADO=TRUE LOOP
        V_ASCII:=ASCII(SUBSTR(V_FRASE,V_INDICE,1));
        IF V_ASCII NOT BETWEEN 48 AND 57 THEN
            V_RESULTADO:=FALSE;
        END IF;
        V_INDICE:=V_INDICE+1;
    END LOOP;
  RETURN V_RESULTADO;
END VALIDADOR_NUMERO;
---------------------------------------------------------------------------------------------
BEGIN
    IF LENGTH(V_CUENTA)=20 THEN
        IF VALIDADOR_NUMERO(V_CUENTA)=TRUE THEN
             V_DCCORRECTO:=TO_NUMBER(CALCULO_DC(SUBSTR(V_CUENTA,1,8),SUBSTR(V_CUENTA,11,10)));
             V_DC:=TO_NUMBER(SUBSTR(V_CUENTA,9,2));
             IF V_DCCORRECTO=V_DC THEN
                V_RESULTA:=TRUE;
             ELSE
                    RAISE_APPLICATION_ERROR(-20003,'Los digitos de control no son correctos');
             END IF;
        ELSE
            RAISE_APPLICATION_ERROR(-20001,'El numero de cuenta no puede contener letras');
        END IF;
    ELSE
          RAISE_APPLICATION_ERROR(-20000,'El numero de cuenta completo debe tener 20 digitos');
    END IF;
  RETURN V_RESULTA;
END VALIDARNUMEROCUENTA;

--Procedimiento para añadir una cuenta ajena
PROCEDURE ADDCUENTAAJENA (P_NCUENTA IN VARCHAR2) AS
BEGIN
IF VALIDARNUMEROCUENTA(P_NCUENTA)=TRUE THEN
    INSERT INTO CUENTA VALUES (P_NCUENTA,'AJENA',null);
END IF;
END ADDCUENTAAJENA;

--procedimiento que nos dejará hacer un ingreso en una cuenta de tipo propia

PROCEDURE INGRESO (P_NCUENTA VARCHAR2, P_CANTIDADINGRESO NUMBER, P_CONCEPTO VARCHAR2) IS
V_CUENTA CUENTA%ROWTYPE;
V_NMOVIMIENTO NUMBER;
V_INGRESO NUMBER;
E_CUENTAINVALIDA EXCEPTION;
BEGIN
IF VALIDARNUMEROCUENTA(P_NCUENTA)=TRUE THEN
    SELECT * INTO V_CUENTA FROM CUENTA WHERE CUENTA.NCTA=P_NCUENTA;
    IF V_CUENTA.TIPO='PROPIA' THEN
        SELECT S_NUMEROMOVIMIENTO.NEXTVAL INTO V_NMOVIMIENTO FROM DUAL;
        SELECT operacion.codigooperacion INTO V_INGRESO FROM OPERACION WHERE DESCRIPCION='INGRESO';
        UPDATE CUENTA SET cuenta.saldo=cuenta.saldo+P_CANTIDADINGRESO WHERE cuenta.ncta=P_NCUENTA;
        INSERT INTO MOVIMIENTO VALUES (TO_DATE(SYSDATE),V_NMOVIMIENTO,P_NCUENTA,V_INGRESO,P_CANTIDADINGRESO,P_CONCEPTO);
    ELSE
        RAISE E_CUENTAINVALIDA;
    END IF;
END IF;
EXCEPTION
    WHEN E_CUENTAINVALIDA THEN
         RAISE_APPLICATION_ERROR(-20000,'Para hacer el ingreso la cuenta tiene que ser propia');
    WHEN OTHERS THEN 
        RAISE_APPLICATION_ERROR(-20001,'HA OCURRIDO UN ERROR AL REALIZAR EL INGRESO');
END INGRESO;

--procedimiento que nos dejará hacer un CARGO en una cuenta de tipo propia
PROCEDURE CARGO (P_NCUENTA VARCHAR2, P_CANTIDADCARGO NUMBER, P_CONCEPTO VARCHAR2) IS
V_CUENTA CUENTA%ROWTYPE;
V_NMOVIMIENTO NUMBER;
V_INGRESO NUMBER;
E_CUENTAINVALIDA EXCEPTION;
E_SALDOINSUFICIENTE EXCEPTION;
BEGIN
IF VALIDARNUMEROCUENTA(P_NCUENTA)=TRUE THEN

    SELECT * INTO V_CUENTA FROM CUENTA WHERE CUENTA.NCTA=P_NCUENTA FOR UPDATE WAIT 3;
    IF V_CUENTA.TIPO!='PROPIA' THEN
        RAISE E_CUENTAINVALIDA;
    END IF;
    
    IF V_CUENTA.SALDO<=P_CANTIDADCARGO THEN
        RAISE E_SALDOINSUFICIENTE;
    END IF;
    
    SELECT operacion.codigooperacion INTO V_INGRESO FROM OPERACION WHERE DESCRIPCION='CARGO';
    SELECT S_NUMEROMOVIMIENTO.NEXTVAL INTO V_NMOVIMIENTO FROM DUAL;
    UPDATE CUENTA SET cuenta.saldo=cuenta.saldo-P_CANTIDADCARGO WHERE cuenta.ncta=P_NCUENTA;
    INSERT INTO MOVIMIENTO VALUES (TO_DATE(SYSDATE),V_NMOVIMIENTO,P_NCUENTA,V_INGRESO,P_CANTIDADCARGO,P_CONCEPTO);
END IF;
EXCEPTION
    WHEN E_CUENTAINVALIDA THEN
         RAISE_APPLICATION_ERROR(-20000,'Para hacer el CARGO la cuenta tiene que ser propia');
    WHEN E_SALDOINSUFICIENTE THEN 
         RAISE_APPLICATION_ERROR(-20002,'NO HAY SUFICIENTE SALDO EN LA CUENTA');
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20003,'NO EXISTE LA CUENTA'||P_NCUENTA);
    WHEN OTHERS THEN 
        RAISE_APPLICATION_ERROR(-20001,'HA OCURRIDO UN ERROR AL REALIZAR EL CARGO');
END CARGO;

--PROCEDIMIENTO DE TRANSFERENCIA 

PROCEDURE TRANSFERENCIA (P_CUENTAACREEDORA VARCHAR2, P_CUENTADEUDORA VARCHAR2, P_IMPORTE NUMBER, P_CONCEPTO VARCHAR2) IS

V_CUENTAACREEDORA CUENTA%ROWTYPE;
V_NMOVIMIENTO NUMBER;
V_INGRESO NUMBER;
E_CUENTASIGUALES EXCEPTION;
E_CUENTAINVALIDA EXCEPTION;
BEGIN

    IF P_CUENTAACREEDORA=P_CUENTADEUDORA THEN
        RAISE  E_CUENTASIGUALES;
    END IF;
    
    IF VALIDARNUMEROCUENTA(P_CUENTAACREEDORA)!=TRUE THEN
     RAISE E_CUENTAINVALIDA;
    END IF;
    CARGO(P_CUENTADEUDORA,P_IMPORTE,'TRANSFERENCIA A LA CUENTA: '||P_CUENTAACREEDORA||'EN CONCEPTO DE: '||P_CONCEPTO);
    SELECT * INTO V_CUENTAACREEDORA FROM CUENTA WHERE CUENTA.NCTA=P_CUENTAACREEDORA FOR UPDATE WAIT 3;
    SELECT operacion.codigooperacion INTO V_INGRESO FROM OPERACION WHERE DESCRIPCION='INGRESO';
    SELECT S_NUMEROMOVIMIENTO.NEXTVAL INTO V_NMOVIMIENTO FROM DUAL;
    UPDATE CUENTA SET cuenta.saldo=cuenta.saldo+P_IMPORTE WHERE cuenta.ncta=P_CUENTAACREEDORA;
    INSERT INTO MOVIMIENTO VALUES (TO_DATE(SYSDATE),V_NMOVIMIENTO,P_CUENTAACREEDORA,V_INGRESO,P_IMPORTE,'TRANSFERENCIA DESDE LA CUENTA: '||P_CUENTADEUDORA||'EN CONCEPTO DE: '||P_CONCEPTO);

EXCEPTION
    WHEN E_CUENTASIGUALES THEN
        RAISE_APPLICATION_ERROR(-20000,'LA CUENTA DEUDORA NO PUEDE SER LA MISMA QUE LA ACREEDORA');
    WHEN E_CUENTAINVALIDA THEN
        RAISE_APPLICATION_ERROR(-20001,'LA CUENTA ACREEDORA NO ES VALIDA');
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20002,'LA CUENTA ACREEDORA NO EXISTE');
END TRANSFERENCIA;
END BANCO;


FUNCIONES:

--------------------->>>>>>>>>>>>>>>>>>SABER SI UN NUMERO ES PRIMO

create or replace FUNCTION ESPRIMO 
(
  P_N1 IN POSITIVE 
) RETURN BOOLEAN AS
V_ESPRIMO BOOLEAN:=TRUE;
V_DIVISOR POSITIVE:=2;
BEGIN
  IF P_N1 IN(1,2,3) THEN
     V_ESPRIMO:=TRUE;
  ELSE
    WHILE (V_DIVISOR<=(P_N1/2)+1) AND V_ESPRIMO LOOP
        IF MOD(P_N1,V_DIVISOR)=0 THEN
            V_ESPRIMO:=FALSE;
        ELSE
            V_DIVISOR:=V_DIVISOR+1;
        END IF;
    END LOOP;
  END IF;
  RETURN V_ESPRIMO;
END ESPRIMO;

------------------->>>>>>>>>>>>>>>>>>>>CALCULO  MCD

create or replace FUNCTION MCD
(
  P_N1 IN NUMBER 
, P_N2 IN NUMBER 
) RETURN NUMBER AS
V_RESUL NUMBER;
V_ENCONTRADO BOOLEAN:=FALSE;
BEGIN
    IF P_N1<=P_N2 THEN
        V_RESUL:=P_N1;
    ELSE 
        V_RESUL:=P_N2;
    END IF;
    WHILE V_ENCONTRADO=FALSE LOOP
        IF (MOD(P_N1,V_RESUL)=0) AND (MOD(P_N2,V_RESUL)=0) THEN
            V_ENCONTRADO:=TRUE;
        ELSE
            V_RESUL:=V_RESUL-1;
        END IF;
    END LOOP;
    RETURN V_RESUL;
END MCD;

------------------>>>>>>>>>>>>>>>>>>>>CALCULO MCM

create or replace FUNCTION MCM 
(
  P_N1 IN POSITIVE 
, P_N2 IN POSITIVE 
) RETURN POSITIVE AS 
V_RESUL POSITIVE; 
V_ENCONTRADO BOOLEAN:=FALSE;
BEGIN
    IF P_N1<=P_N2 THEN  --Empezamos a probar por el mayor
        V_RESUL:=P_N2;
    ELSE 
        V_RESUL:=P_N1;
    END IF;
    WHILE V_ENCONTRADO=FALSE LOOP --Hará el while mientras no encuantre el mcm
        IF (MOD(V_RESUL,P_N1)=0) AND (MOD(V_RESUL,P_N2)=0) THEN --Si el mcm da entre el primer numero y el segundo resto 0 hemos encontrado el msm
            V_ENCONTRADO:=TRUE;
        ELSE --Si no hemos encotrado el mcm incrementamos en 1 el mcm
            V_RESUL:=V_RESUL+1;  
        END IF;
    END LOOP;
    RETURN V_RESUL;
END MCM;

----------------->>>>>>>>>>>>>>>>>>PASAR UN NUMERO ENTERO A ROMANO


create or replace FUNCTION NUMROMANOS 
(
  P_N1 IN NUMBER 
) RETURN VARCHAR2 AS 
TYPE t_tablaromano is varray(13) of varchar(2);
TYPE t_tablaentero is varray(13)of binary_integer;
v_romano t_tablaromano:=t_tablaromano('I','IV','V','IX','X','XL','L','XC','C','CD','D','CM','M');
v_entero t_tablaentero:=t_tablaentero(1,4,5,9,10,40,50,90,100,400,500,900,1000);
V_NUMERO NUMBER:=P_N1;
V_ROMANOS VARCHAR2(20);
V_INDICE NUMBER:=v_entero.last;
BEGIN
  WHILE V_NUMERO>0 LOOP
    IF V_NUMERO>=V_ENTERO(V_INDICE) THEN
        V_NUMERO:=V_NUMERO-V_ENTERO(V_INDICE);
        V_ROMANOS:=V_ROMANOS||V_ROMANO(V_INDICE);
    ELSE
        V_INDICE:=V_INDICE-1;
    END IF;
  END LOOP;

  RETURN V_ROMANOS;
END NUMROMANOS;

##########################################  M A T R I C U L A  ##########################################

PROCEDIMIENTOS:

---------------------------->>>>>>>>>>>>>>>>>>>>>PARA MATRICULAR A UN ALUMNO EN UNA ASIGNATURA

create or replace PROCEDURE MATRICULARESTUDIANTES (P_ESTUDIANTE NUMBER,P_ASIGNATURA NUMBER) AS 

V_ENCONTRADO VARCHAR2(4);
V_ASIGNOAPROVADAS VARCHAR2(100):='';
V_ASIGNOAPROVADA VARCHAR2(30);
V_CUMPLEREQUISITO BOOLEAN:=TRUE;

CURSOR C_ASIGNATURASCIERRE (ASIGNATURACIERRE NUMBER) IS
SELECT c.asigquecierra codigo,a.nombre asignatura
FROM cierreasignatura c,asignatura a
WHERE c.asigcerrada=ASIGNATURACIERRE
and a.codigo=c.asigquecierra;

BEGIN
--BLOQUE PARA SABER SI EL ALUMNO EXISTE
    BEGIN
      SELECT 'X' INTO V_ENCONTRADO FROM estudiante WHERE codigo=P_ESTUDIANTE;
      EXCEPTION 
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20000,'EL ESTUDIANTE INTRODUCIDO NO ES VÁLIDO');
    END;
--BLOQUE PARA SABER SI LA ASIGNATURA EXISTE
    BEGIN
      SELECT 'X' INTO V_ENCONTRADO FROM asignatura WHERE codigo=P_ASIGNATURA;
      EXCEPTION 
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20001,'LA ASIGNATURA INTRODUCIDA NO ES VÁLIDA');
    END;
--BLOQUE PARA SABER SI EL ALUMNO YA TIENE APROBADA LA ASIGNATURA
BEGIN
    SELECT 'X' INTO V_ENCONTRADO FROM asignaturaAPROBADA WHERE ASIGNATURA=P_ASIGNATURA AND ESTUDIANTE=P_ESTUDIANTE;
    SELECT asignatura.nombre INTO V_ASIGNOAPROVADA FROM ASIGNATURA WHERE codigo=p_asignatura;
    RAISE_APPLICATION_ERROR(-20002,'EL ALUMNO YA TIENE APROBADA LA ASIGNATURA: '||v_asignoaprovada);
EXCEPTION 
    WHEN NO_DATA_FOUND THEN
        NULL;
END;
--PARA MATRICULAR EN ASIGNATURAS
    FOR V_ASIGNATURAQUECIERRA IN C_ASIGNATURASCIERRE(P_ASIGNATURA) LOOP
        BEGIN
         SELECT 'X' INTO V_ENCONTRADO FROM asignaturaaprobada WHERE asignatura=V_ASIGNATURAQUECIERRA.codigo AND estudiante=P_ESTUDIANTE;
        EXCEPTION 
            WHEN NO_DATA_FOUND THEN
                V_ASIGNOAPROVADA:=v_asignaturaquecierra.asignatura;
                V_ASIGNOAPROVADAS:=V_ASIGNOAPROVADAS||V_ASIGNOAPROVADA||', ';
                V_CUMPLEREQUISITO:=FALSE;
        END;
    END LOOP;
    IF V_CUMPLEREQUISITO=TRUE THEN
        INSERT INTO MATRICULA(ESTUDIANTE,ASIGNATURA) VALUES (P_ESTUDIANTE,P_ASIGNATURA);
    ELSE
        RAISE_APPLICATION_ERROR(-20003,'EL ESTUDIANTE NO TIENE APROBADADAS LAS ASIGNATURA/S: '||V_ASIGNOAPROVADAS);
    END IF;
END MATRICULARESTUDIANTES;


##########################################  C I C L O S  ##########################################

------------------------>>>>>>>>>>>>>>SACAR SOLICITUDES DE UN ALUMNO

create or replace PROCEDURE GETSOLICITUDESTUDIANTE (P_ESTUDIANTE solicita.idestudiante%TYPE) AS
  CURSOR C_SOLICITUDES(P_ESTUDIANTE SOLICITA.idestudiante%TYPE) IS
  SELECT * 
  FROM SOLICITA
  WHERE SOLICITA.idestudiante=P_ESTUDIANTE;
  V_SOLICITUDES SOLICITA%ROWTYPE;
BEGIN
  OPEN C_SOLICITUDES(P_ESTUDIANTE);
  FETCH C_SOLICITUDES INTO V_SOLICITUDES;
    WHILE C_SOLICITUDES%FOUND LOOP
        INSERT INTO RESULTADOS VALUES (v_solicitudes.IDESTUDIANTE||'--'||V_SOLICITUDES.IDIES||'--'||V_SOLICITUDES.IDCICLO||'--'
        ||V_SOLICITUDES.PREFERENCIA);
        FETCH C_SOLICITUDES INTO V_SOLICITUDES;
    END LOOP;
  CLOSE C_SOLICITUDES;
END GETSOLICITUDESTUDIANTE;


-------------------------->>>>>>>>>>>>>>>OBTENER ASIGNACION

create or replace PROCEDURE OBTENERASIGNACION AS 
  CURSOR C_SOLICITUDES(P_ESTUDIANTE SOLICITA.idestudiante%TYPE) IS
  SELECT * 
  FROM SOLICITA
  WHERE SOLICITA.idestudiante=P_ESTUDIANTE
  ORDER BY SOLICITA.PREFERENCIA;
  CURSOR C_ESTUDIANTE IS
  SELECT *
  FROM ESTUDIANTE
  ORDER BY estudiante.notamedia DESC;
  V_ESTUDIANTE ESTUDIANTE%ROWTYPE;
  V_PLAZASASIGNADAS NUMBER;
  V_PLAZASOFERTADAS NUMBER;
BEGIN
  OPEN C_ESTUDIANTE;
  FETCH C_ESTUDIANTE INTO V_ESTUDIANTE;
    WHILE C_ESTUDIANTE%FOUND LOOP
        FOR R_SOLICITUD IN  C_SOLICITUDES (V_ESTUDIANTE.IDESTUDIANTE)LOOP
              SELECT OE.PLAZAS into V_PLAZASOFERTADAS
                FROM OFERTAEDUCATIVA OE
                WHERE OE.IDIES=R_SOLICITUD.IDIES
                AND OE.IDCICLO=R_SOLICITUD.IDCICLO
                AND OE.TURNO=R_SOLICITUD.TURNO;
                 SELECT COUNT(A.IDESTUDIANTE) INTO V_PLAZASASIGNADAS
                    FROM ASIGNACION A
                    WHERE A.IDIES=R_SOLICITUD.IDIES
                    AND A.IDCICLO=R_SOLICITUD.IDCICLO
                    AND A.TURNO=R_SOLICITUD.TURNO;
            IF (V_PLAZASOFERTADAS!=V_PLAZASASIGNADAS) THEN
                 INSERT INTO ASIGNACION VALUES (R_SOLICITUD.IDESTUDIANTE, R_SOLICITUD.IDIES, R_SOLICITUD.IDCICLO,R_SOLICITUD.TURNO);
                 EXIT;
            END IF;
        END LOOP;
        FETCH C_ESTUDIANTE INTO V_ESTUDIANTE;
    END LOOP;
  CLOSE C_ESTUDIANTE;
END OBTENERASIGNACION;

##########################################  C I C L I S M O  ##########################################

----------------------------->>>>>>>>>>>>>>>CALCULA HORAS, MINUTOS Y SEGUNDOS LE ENTRA DIAS

create or replace PROCEDURE CALCULADORHMS 
(
  P_DIAS IN NUMBER 
, P_HORAS OUT NUMBER 
, P_MINUTOS OUT NUMBER 
, P_SEGUNDOS OUT NUMBER 
) AS 
V_AUXILIAR NUMBER;
BEGIN
   V_AUXILIAR:=P_DIAS*24;
   P_HORAS:=TRUNC(V_AUXILIAR,0);
   V_AUXILIAR:=(V_AUXILIAR-P_HORAS)*60;
   P_MINUTOS:=TRUNC(V_AUXILIAR,0);
   V_AUXILIAR:=(V_AUXILIAR-P_MINUTOS)*60;
   P_SEGUNDOS:=TRUNC(V_AUXILIAR,0);
END CALCULADORHMS;


--------------------------->>>>>>>>>>>>>>>>PARA OBTENER LA CLASIFICACION GENERAL

CREATE OR REPLACE PROCEDURE CLASIFICACIONPRUEBAS AS 

CURSOR C_TIEMPOCORREDORDIAS IS
SELECT ce.corredor CORREDOR,SUM(ce.llegada-e.inicio) DIAS
FROM CLASIFICACIONETAPA CE, ETAPA E
WHERE CE.ETAPA=E.NUMERO
GROUP BY ce.corredor;

V_HORAS NUMBER;
V_MINUTOS NUMBER;
V_SEGUNDOS NUMBER;
BEGIN
  FOR R_TIEMPOCORREDOR IN C_TIEMPOCORREDORDIAS LOOP
    PRUEBACALCULADOR(R_TIEMPOCORREDOR.DIAS,V_HORAS,V_MINUTOS,V_SEGUNDOS);
    INSERT INTO clasificaciongeneral VALUES (R_TIEMPOCORREDOR.CORREDOR,V_HORAS,V_MINUTOS,V_SEGUNDOS);
  END LOOP;
END CLASIFICACIONPRUEBAS;